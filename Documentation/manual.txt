Device Tree Compiler Manual
===========================

I - "dtc", the device tree compiler
    1) Obtaining Sources
    2) Description
    3) Command Line
    4) Source File
    4.1) Overview
    4.2) Properties
    4.3) Labels and References

II - The DT block format
    1) Header
    2) Device tree generalities
    3) Device tree "structure" block
    4) Device tree "strings" block


III - libfdt

IV - Utility Tools
    1) convert-dtsv0 -- Conversion to Version 1
    1) ftdump


I - "dtc", the device tree compiler
===================================

1) Sources

Source code for the Device Tree Compiler can be found at jdl.com.
The gitweb interface is:

    http://git.jdl.com/gitweb/

The repository is here:

    git://www.jdl.com/software/dtc.git
    http://www.jdl.com/software/dtc.git

Tarballs of the 1.0.0 and latest releases are here:

    http://www.jdl.com/software/dtc-v1.2.0.tgz
    http://www.jdl.com/software/dtc-latest.tgz


2) Description

The Device Tree Compiler, dtc, takes as input a device-tree in
a given format and outputs a device-tree in another format.
Typically, the input format is "dts", a human readable source
format, and creates a "dtb", or binary format as output.

The currently supported Input Formats are:

    - "dtb": "blob" format.  A flattened device-tree block with
        header in one binary blob.

    - "dts": "source" format.  A text file containing a "source"
        for a device-tree.

    - "fs" format.  A representation equivalent to the output of
        /proc/device-tree  where nodes are directories and
	properties are files.

The currently supported Output Formats are:

     - "dtb": "blob" format

     - "dts": "source" format

     - "asm": assembly language file.  A file that can be sourced
        by gas to generate a device-tree "blob".  That file can
        then simply be added to your Makefile.  Additionally, the
        assembly file exports some symbols that can be used.


3) Command Line

The syntax of the dtc command line is:

    dtc [options] [<input_filename>]

Options:

    <input_filename>
	The name of the input source file.  If no <input_filename>
	or "-" is given, stdin is used.

    -b <number>
	Set the physical boot cpu.

    -f
	Force.  Try to produce output even if the input tree has errors.

    -h
	Emit a brief usage and help message.

    -I <input_format>
	The source input format, as listed above.

    -o <output_filename>
	The name of the generated output file.  Use "-" for stdout.

    -O <output_format>
	The generated output format, as listed above.

    -q
	Quiet: -q suppress warnings, -qq errors, -qqq all

    -D <id>
    -D <id>=<value>
	Introduce a constant definition for symbol <id> with
	possible initial value given by <value>.  The RHS
	should be a literal number or string value.

    -p <padsize>
	Add at least <padsize> additional space to the DTB image.

    -R <number>
	Make space for <number> reserve map entries
	Relevant for dtb and asm output only.

    -S <bytes>
	Deprecated option.

    -v
	Print DTC version and exit.

    -V <output_version>
	Generate output conforming to the given <output_version>.
	By default the most recent version is generated.
	Relevant for dtb and asm output only.


The <output_version> defines what version of the "blob" format will be
generated.  Supported versions are 1, 2, 3, 16 and 17.  The default is
always the most recent version and is likely the highest number.

Additionally, dtc performs various sanity checks on the tree.


4) Device Tree Source file


4.1) DTS Lexical Components

Property and node names		[a-zA-Z0-9,._+*#?@-]+
Identifiers			\\[a-zA-Z_][a-zA-Z0-9_]*
Labels				[a-zA-Z_][a-zA-Z0-9_]*
Strings				<C-style-double-quoted-strings>
Comments			Both /* ... */ and // style are supported
Numeric literals		<C-style-integer-numbers>
Bytes				[0-9a-fA-F][0-9a-fA-F]

Keywords:
	else
	for
	if
	in
	return
	void
	/const/
	/define/
	/incbin/

C-style expression operators:
	<<
	>>
	<=
	>=
	==
	!=
	&&
	||
	+
	-
	*
	/
	%

Additional tokens:
	..
	:=
	{
	}
	,
	&


These constructs are handled and eliminated purely at the
lexical level and do not appear in the grammar proper:

    - Source files included using the syntax:

        /include/ "filename"

    - Both classic C style and C++ style comments are supported.
      Comments don't nest.
      For example, given:

	1    /*
	2     *  asdasdasd  // asdasdad
	3     //   */
	4    asasd
	5     */
      The // comment on line 3 is not effective and is ignored.
      The original /* comment ends on line 3.  Line 5 is in error.

      And given:

	1    // /*
	2     *  asdasdasd  // asdasdad
	3     */

      The // comment on line 1 hides the opening /*.
      Line 2 is in error.


4.2) DTS Grammar

Here is a very rough overview of the grammar of a DTS source file:


    sourcefile:
		'/dts-v1/' ';' possibly_empty_list_of_declarations devicetree

    declaration:
		  memreserve
		| constdef
		| funcdef

    memreserve:	label '/memreserve/' addr addr ';'

    constdef:	'/const/' identifier '=' expr ';'

    funcdef:	'/define/' identifier paramdecls statement_block

    paramdecls:	'(' possibly_empty_paramdecl_list ')'

    paramdecl: identifier

    devicetree:   '/' statement_block

    statement_block: '{' possibly_empty_list_of_statements '}'

    statement:
		  subnode
		| for_statement
		| if_statement
		| return_statement
		| assign_statement
		| property_definition
		| statement_block
		| ';'

    subnode:
		  node_label expr statement_block ';'
		|      label expr statement_block ';'
		|            expr statement_block ';'

    for_statement:
		'for' identifier 'in' expr '..' expr statement_block

    if_statement:
		  'if' '(' expr ')' statement_block
		| 'if' '(' expr ')' statement_block 'else' statement_block

    return_statement: 'return' expr ';'

    assign_statement: identifier ':=' expr ';'

    property_definition:
		  optional_label expr ';'
		| optional_label expr '=' list_of_property_data_and_labels ';'

    list_of_property_data_and_labels:
		  STRING
		| '<' possibly_empty_list_of_cell_values_and_labels '>'
		| '[' possibly_empty_list_of_byte_values_and_labels ']'
		| label
		| '/incbin/' '(' expr ')'
		| '/incbin/' '(' expr ',' expr ',' expr ')'

    cell_value:
		  expr_primary
		| '&' '(' expr ')'
		| '&' phandle_reference
		| label


    expr:
          expr_primary
	| expr '?' expr ':' expr
	| expr expr_oper expr

    expr_oper:
	||
        &&
	|
	^
	&
	==
	< | > | <= | >=
	<< | >>
	+ | -
	* | / | %
	- | ~ | !
        '(' ')' | '(' non_empty_list_of_param_exprs ')'

    expr_primary:
	  literal
	| string
	| propnodename
	| identifier
	| '(' expr ')'

    addr:	expr

    node_label:	expr ':'

    propnodename: <1275-property-name>

    identifier:	'\'-<C style name>

    literal:	<C style number>
    byte:	<exactly two hex digits>
    string:	<C style string>
    label:	'&'-<label name>-':'


4.2) Overview

The DTS source file begins with the '/dts-v1/' token to state
that it is using "Version 1" style source files.

Any declarations are executed in order, and can use the
effects of earlier declarations.

All declarations must precede the required root node definition,
which is introduced with the '/'-named node:

    / {
	...
    }

The statement-block structure forms a hierarchical layout of nodes
and properties along with some control-statements that allow for
repeated and alternate statement blocks.


4.3) Declarations

An arbitrary list of declarations can be made between '/dts-v1/'
and the beginning of the root node.  These declarations are
introduced in order.


4.3.1) Memory Reservations

A memory reservation is a declaration that a block of memory
from the first address expression, with a size given by the
second address expression, is to be "reserved" and not used
by the kernel.  These address ranges are passed through to
the DTB to the kernel.


4.3.2) Function Definitions

A function definition can be introduced using /define/.
These definitions are just "stored" and then later invoked as
either a subroutine in a statement context, or as a function
with a return value in an expression context.

Functions declare the number of formal parameters which will
be passed in at the call site, and must match one-to-one.

Any property definitions generated by the function are emitted
into the caller's context at the point of the call.

Any node definitions generated by the function are emitted
into the caller's context at the point of the call.


4.3.3) Constant Definitions

Constant definitions introduce a named identifier into the outer-most
symbol scope.  The constants can not be changed by later assignment
statements, though they can be hidden.  (Be careful.)

Constants may be expressions yielding constant numeric or strings
values.  It is an error for them not to be evaluatable at their
point of definition.

Constant definitions may also be introduced from the command line
using the '-D var=value" options.  They will be placed into the
same outer-most scope.  Constant definitions from the command line
override the definitions within the source file, but with a warning.


4.4) Statements

A statement block is simply a list of sequentially executed
statements introduced with a required opening brace and terminated
with a required closing brace.

4.4.1) Subnodes

Node may contain sub-nodes to obtain a hierarchical structure.

For example:

    - A child node named "childnode" whose unit name is
      "childnode at address".  It it turn has a string property
      called "childprop".

	childnode@address {
	    childprop = "hello\n";
	};


4.4.2) 'for' Statement

The 'for' statement provides iterative execution of a
block of statements.

The lower bound of the range is evaluated once, and the
upper bound is evaluated once.

A new scope that contains the loop variable is created
and pushed onto the symbol table scope stack.  The loop
variable is initialized with the lower bound value.

The statement block is executed once for each inclusive value
in the given range in increasing order.

After the loop terminates, the loop variable scope is popped.


4.4.3) 'if' Statement

The 'if' statement provides alternate execution flow paths.
The expression is evaluated once, and if non-zero, the fist
statement block is executed, otherwise the 'else' block of
statements is executed if present.


4.4.4) 'return' Statement

Inside a function definition, the 'return' statement allows
a value to be passed back to the caller.  The return expression
is evaluated once, in the context of the function's scope,
and its resultant value is made available as the function's
return result.


4.4.5) Assign Statement

The ':=' operator allows assignment to non-constant identifiers.

The identifiers can be either formal parameters or variable as
found by the searching using the dynamic symbol table scoping rules.

An assignment to an otherwise unknown identifier causes that
identifier to be introduced into the current scope.

You can't assign to /constant/ identifiers (except in the initial
definition of them).


4.4.6) Property Definition

Properties are named, possibly labeled, values.
Each value within a property is one of:

    - A null-terminated C-like string,
    - A numeric value fitting in 32 bits,
    - A list of 32-bit values
    - A byte sequence

Here are some example property definitions:

    - A property containing a 0 terminated string

	property1 = "string_value";

    - A property containing a numerical 32-bit hexadecimal value

	property2 = <1234abcd>;

    - A property containing 3 numerical 32-bit hexadecimal values

	property3 = <12345678 12345678 deadbeef>;

    - A property whose content is an arbitrary array of bytes

	property4 = [0a 0b 0c 0d de ea ad be ef];


4.4.7) Subroutine calls

An expression at the statement level should be a function call,
though it might be considered as just a "subroutine call" as
any return value is thrown away.

Invocation of the function introduces a symbol table scope
in which the formal paramters are introduced and bound.
Initial values for the formals are obtained by evaluating
the actual parameters, in order, and using a copy-in binding.

Any incidental (dynamically occurring) assignment to an
otherwise unknown identifier will cause the introduction of
a new variable in the function's execution scope.

Any property definitions generated by the function are emitted
into the caller's context at the point of the subroutine call.

Any node definitions generated by the function are emitted
into the caller's context at the point of the subroutine call.

Any return value from a return statement is thrown away.

Execution control is returned to the point of the call.


4.5) Expressions

Basically, expressions follow C conventions.  However, there
are no assignment operations such as +=, or pre-/post-
increment/decrement.

The '%' operation is a modulus operation for integers, and
a string concatenation operation if at least one of the operands
is determined to be a string value.


4.5.1) Expressions

Pretend it is C and see how close we get.


4.5.2) Function Invocations

A previously defined function may be invoked from within an
expression.  A "return" statement should be used to return
a resulting expression value to the caller's context.

Invocation of the function introduces a symbol table scope
in which the formal parameters are introduced and bound.
Initial values for the formals are obtained by evaluating
the actual parameters, in order, and using a copy-in binding.

Any incidental (dynamically occurring) assignment to an
otherwise unknown identifier will cause the introduciton of
a new variable in the function's execution scope.

Any property definitions generated by the function are emitted
into the caller's context at the point of the subroutine call.

Any node definitions generated by the function are emitted
into the caller's context at the point of the subroutine call.

Any return value from a return statement is used as the result
of the function call within the context of the original expression.

Execution control is returned to the point of the call.


4.5.3) Builtin Functions

There are a few builtin function names;

    join()	Concatenate and return a list of expression
		as a string.  Non-string arguments are coerced
		into being a string.

    hexstr()	Format and return a hex string representation
		of the one parameter without a leading '0x'.

    list()	Yields a list composed of each parameter.

    cell()	Yields a cell-sized result for one parameter.

While not here yet, /incbin/ should be converted into a builtin.


4.5.4) Literal Numbers

Literal numbers follow C conventions.  Specifically, they are
base-ten by default, but can be hexadecimal, binary or octal
with a leading 0x or 0X, 0b or OB, or a simple leading zero,
respectively.

There is no support for floating point representations at all.

Most math and expression handling is assumed to be 64-bit, but
a cell-context may force a 32-bit container instead.


4.5.5) Literal Strings

Strings support common escape sequences from C:
    "\n", "\t", "\r"
    "\(octal value)"
    "\x(hex value)"


4.5.6) Identifiers

Identifiers references are resolved using dynamic symbol table
scoping rules.  An identifier referenced on the right-hand-side
of an expression must be resolvable or else it is an error.

An identifier occurring on the left-hand-side of a ':=' assignment
is first sought and used if found.  If it is not found, it is
introduced dynamically in the innermost, current scope.

Sometimes identifiers can be used without the leading slash,
other times they are required, especially if to disambiguate
from property names.  It's not ideal yet at all.


4.6) Labels and References

Labels may be applied to nodes or properties.  Labels appear
before a node name, and are referenced using an ampersand: &label.
Absolute node path names are also allowed in node references.

In this exmaple, a node is labled "mpic" and then referenced:

    mpic:  interrupt-controller@40000 {
	...
    };

    ethernet-phy@3 {
	interrupt-parent = <&mpic>;
	...
    };

And used in properties, lables may appear before or after any value:

    randomnode {
	prop: string = data: "mystring\n" data_end: ;
	...
    };

The names of some labels can be constructed in an expression
context using the representation "&( <string_expr> )".


4.7) Symbol Table

During the execution of the program, the evaluation context for
both statements and expressions is performed in the context of
a dynamic scoping environment.  That is, as each function,
subroutine or for-loop is encountered, a new symbol table scope
is pushed onto a dynamic run-time stack.  When an identifier's
name needs to be resolved and a value for it determined, a
search is performed from the inner-most, current top of the
scope-stack back through the dynamic scope stack towards the
outer-most and earliest scope.

At each scope, an attempt is made to locate the symbol.  If it
is found, that is the symbol that is used.  If the symbol can not
be found at any level, it may be an error, or it may be cause to
introduce the symbol, as determined by the context in which the
identifier occurs.

Constants from the command line using the "-D id=value" construct
are introduced into the outermost scope prior to beginning to
execute the source file proper.  This is the same outer-most scope
into which the /const/ and /define/ function symbols are also
introduced.



II - The DT block format
========================

This chapter defines the format of the flattened device-tree
passed to the kernel. The actual content of the device tree
are described in the kernel documentation in the file

    linux-2.6/Documentation/powerpc/booting-without-of.txt

You can find example of code manipulating that format within
the kernel.  For example, the file:

	including arch/powerpc/kernel/prom_init.c

will generate a flattened device-tree from the Open Firmware
representation.  Other utilities such as fs2dt, which is part of
the kexec tools, will generate one from a filesystem representation.
Some bootloaders such as U-Boot provide a bit more support by
using the libfdt code.

For booting the kernel, the device tree block has to be in main memory.
It has to be accessible in both real mode and virtual mode with no
mapping other than main memory.  If you are writing a simple flash
bootloader, it should copy the block to RAM before passing it to
the kernel.


1) Header
---------

The kernel is entered with r3 pointing to an area of memory that is
roughly described in include/asm-powerpc/prom.h by the structure
boot_param_header:

    struct boot_param_header {
        u32     magic;                  /* magic word OF_DT_HEADER */
        u32     totalsize;              /* total size of DT block */
        u32     off_dt_struct;          /* offset to structure */
        u32     off_dt_strings;         /* offset to strings */
        u32     off_mem_rsvmap;         /* offset to memory reserve map */
        u32     version;                /* format version */
        u32     last_comp_version;      /* last compatible version */

        /* version 2 fields below */
        u32     boot_cpuid_phys;        /* Which physical CPU id we're
                                           booting on */
        /* version 3 fields below */
        u32     size_dt_strings;        /* size of the strings block */

        /* version 17 fields below */
        u32	size_dt_struct;		/* size of the DT structure block */
    };

Along with the constants:

    /* Definitions used by the flattened device tree */
    #define OF_DT_HEADER            0xd00dfeed      /* 4: version,
						       4: total size */
    #define OF_DT_BEGIN_NODE        0x1             /* Start node: full name
						       */
    #define OF_DT_END_NODE          0x2             /* End node */
    #define OF_DT_PROP              0x3             /* Property: name off,
						       size, content */
    #define OF_DT_END               0x9

All values in this header are in big endian format, the various
fields in this header are defined more precisely below.  All "offset"
values are in bytes from the start of the header; that is from the
value of r3.

   - magic

     This is a magic value that "marks" the beginning of the
     device-tree block header. It contains the value 0xd00dfeed and is
     defined by the constant OF_DT_HEADER

   - totalsize

     This is the total size of the DT block including the header. The
     "DT" block should enclose all data structures defined in this
     chapter (who are pointed to by offsets in this header). That is,
     the device-tree structure, strings, and the memory reserve map.

   - off_dt_struct

     This is an offset from the beginning of the header to the start
     of the "structure" part the device tree. (see 2) device tree)

   - off_dt_strings

     This is an offset from the beginning of the header to the start
     of the "strings" part of the device-tree

   - off_mem_rsvmap

     This is an offset from the beginning of the header to the start
     of the reserved memory map. This map is a list of pairs of 64-
     bit integers. Each pair is a physical address and a size. The
     list is terminated by an entry of size 0. This map provides the
     kernel with a list of physical memory areas that are "reserved"
     and thus not to be used for memory allocations, especially during
     early initialization. The kernel needs to allocate memory during
     boot for things like un-flattening the device-tree, allocating an
     MMU hash table, etc... Those allocations must be done in such a
     way to avoid overriding critical things like, on Open Firmware
     capable machines, the RTAS instance, or on some pSeries, the TCE
     tables used for the iommu. Typically, the reserve map should
     contain _at least_ this DT block itself (header,total_size). If
     you are passing an initrd to the kernel, you should reserve it as
     well. You do not need to reserve the kernel image itself. The map
     should be 64-bit aligned.

   - version

     This is the version of this structure. Version 1 stops
     here. Version 2 adds an additional field boot_cpuid_phys.
     Version 3 adds the size of the strings block, allowing the kernel
     to reallocate it easily at boot and free up the unused flattened
     structure after expansion. Version 16 introduces a new more
     "compact" format for the tree itself that is however not backward
     compatible. Version 17 adds an additional field, size_dt_struct,
     allowing it to be reallocated or moved more easily (this is
     particularly useful for bootloaders which need to make
     adjustments to a device tree based on probed information). You
     should always generate a structure of the highest version defined
     at the time of your implementation. Currently that is version 17,
     unless you explicitly aim at being backward compatible.

   - last_comp_version

     Last compatible version. This indicates down to what version of
     the DT block you are backward compatible. For example, version 2
     is backward compatible with version 1 (that is, a kernel build
     for version 1 will be able to boot with a version 2 format). You
     should put a 1 in this field if you generate a device tree of
     version 1 to 3, or 16 if you generate a tree of version 16 or 17
     using the new unit name format.

   - boot_cpuid_phys

     This field only exist on version 2 headers. It indicate which
     physical CPU ID is calling the kernel entry point. This is used,
     among others, by kexec. If you are on an SMP system, this value
     should match the content of the "reg" property of the CPU node in
     the device-tree corresponding to the CPU calling the kernel entry
     point (see further chapters for more informations on the required
     device-tree contents)

   - size_dt_strings

     This field only exists on version 3 and later headers.  It
     gives the size of the "strings" section of the device tree (which
     starts at the offset given by off_dt_strings).

   - size_dt_struct

     This field only exists on version 17 and later headers.  It gives
     the size of the "structure" section of the device tree (which
     starts at the offset given by off_dt_struct).

So the typical layout of a DT block (though the various parts don't
need to be in that order) looks like this (addresses go from top to
bottom):

             ------------------------------
       r3 -> |  struct boot_param_header  |
             ------------------------------
             |      (alignment gap) (*)   |
             ------------------------------
             |      memory reserve map    |
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |    device-tree structure   |
             |                            |
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |     device-tree strings    |
             |                            |
      -----> ------------------------------
      |
      |
      --- (r3 + totalsize)

  (*) The alignment gaps are not necessarily present; their presence
      and size are dependent on the various alignment requirements of
      the individual data blocks.


2) Device tree generalities
---------------------------

This device-tree itself is separated in two different blocks, a
structure block and a strings block. Both need to be aligned to a 4
byte boundary.

First, let's quickly describe the device-tree concept before detailing
the storage format. This chapter does _not_ describe the detail of the
required types of nodes & properties for the kernel, this is done
later in chapter III.

The device-tree layout is strongly inherited from the definition of
the Open Firmware IEEE 1275 device-tree. It's basically a tree of
nodes, each node having two or more named properties. A property can
have a value or not.

It is a tree, so each node has one and only one parent except for the
root node who has no parent.

A node has 2 names. The actual node name is generally contained in a
property of type "name" in the node property list whose value is a
zero terminated string and is mandatory for version 1 to 3 of the
format definition (as it is in Open Firmware). Version 16 makes it
optional as it can generate it from the unit name defined below.

There is also a "unit name" that is used to differentiate nodes with
the same name at the same level, it is usually made of the node
names, the "@" sign, and a "unit address", which definition is
specific to the bus type the node sits on.

The unit name doesn't exist as a property per-se but is included in
the device-tree structure. It is typically used to represent "path" in
the device-tree. More details about the actual format of these will be
below.

The kernel powerpc generic code does not make any formal use of the
unit address (though some board support code may do) so the only real
requirement here for the unit address is to ensure uniqueness of
the node unit name at a given level of the tree. Nodes with no notion
of address and no possible sibling of the same name (like /memory or
/cpus) may omit the unit address in the context of this specification,
or use the "@0" default unit address. The unit name is used to define
a node "full path", which is the concatenation of all parent node
unit names separated with "/".

The root node doesn't have a defined name, and isn't required to have
a name property either if you are using version 3 or earlier of the
format. It also has no unit address (no @ symbol followed by a unit
address). The root node unit name is thus an empty string. The full
path to the root node is "/".

Every node which actually represents an actual device (that is, a node
which isn't only a virtual "container" for more nodes, like "/cpus"
is) is also required to have a "device_type" property indicating the
type of node .

Finally, every node that can be referenced from a property in another
node is required to have a "linux,phandle" property. Real open
firmware implementations provide a unique "phandle" value for every
node that the "prom_init()" trampoline code turns into
"linux,phandle" properties. However, this is made optional if the
flattened device tree is used directly. An example of a node
referencing another node via "phandle" is when laying out the
interrupt tree which will be described in a further version of this
document.

This "linux, phandle" property is a 32-bit value that uniquely
identifies a node. You are free to use whatever values or system of
values, internal pointers, or whatever to generate these, the only
requirement is that every node for which you provide that property has
a unique value for it.

Here is an example of a simple device-tree. In this example, an "o"
designates a node followed by the node unit name. Properties are
presented with their name followed by their content. "content"
represents an ASCII string (zero terminated) value, while <content>
represents a 32-bit hexadecimal value. The various nodes in this
example will be discussed in a later chapter. At this point, it is
only meant to give you a idea of what a device-tree looks like. I have
purposefully kept the "name" and "linux,phandle" properties which
aren't necessary in order to give you a better idea of what the tree
looks like in practice.

  / o device-tree
      |- name = "device-tree"
      |- model = "MyBoardName"
      |- compatible = "MyBoardFamilyName"
      |- #address-cells = <2>
      |- #size-cells = <2>
      |- linux,phandle = <0>
      |
      o cpus
      | | - name = "cpus"
      | | - linux,phandle = <1>
      | | - #address-cells = <1>
      | | - #size-cells = <0>
      | |
      | o PowerPC,970@0
      |   |- name = "PowerPC,970"
      |   |- device_type = "cpu"
      |   |- reg = <0>
      |   |- clock-frequency = <5f5e1000>
      |   |- 64-bit
      |   |- linux,phandle = <2>
      |
      o memory@0
      | |- name = "memory"
      | |- device_type = "memory"
      | |- reg = <00000000 00000000 00000000 20000000>
      | |- linux,phandle = <3>
      |
      o chosen
        |- name = "chosen"
        |- bootargs = "root=/dev/sda2"
        |- linux,phandle = <4>

This tree is almost a minimal tree. It pretty much contains the
minimal set of required nodes and properties to boot a linux kernel;
that is, some basic model informations at the root, the CPUs, and the
physical memory layout.  It also includes misc information passed
through /chosen, like in this example, the platform type (mandatory)
and the kernel command line arguments (optional).

The /cpus/PowerPC,970@0/64-bit property is an example of a
property without a value. All other properties have a value. The
significance of the #address-cells and #size-cells properties will be
explained in chapter IV which defines precisely the required nodes and
properties and their content.


3) Device tree "structure" block

The structure of the device tree is a linearized tree structure. The
"OF_DT_BEGIN_NODE" token starts a new node, and the "OF_DT_END_NODE"
ends that node definition. Child nodes are simply defined before
"OF_DT_END_NODE" (that is nodes within the node). A 'token' is a 32
bit value. The tree has to be "finished" with a OF_DT_END token

Here's the basic structure of a single node:

     * token OF_DT_BEGIN_NODE (that is 0x00000001)
     * for version 1 to 3, this is the node full path as a zero
       terminated string, starting with "/". For version 16 and later,
       this is the node unit name only (or an empty string for the
       root node)
     * [align gap to next 4 bytes boundary]
     * for each property:
        * token OF_DT_PROP (that is 0x00000003)
        * 32-bit value of property value size in bytes (or 0 if no
          value)
        * 32-bit value of offset in string block of property name
        * property value data if any
        * [align gap to next 4 bytes boundary]
     * [child nodes if any]
     * token OF_DT_END_NODE (that is 0x00000002)

So the node content can be summarized as a start token, a full path,
a list of properties, a list of child nodes, and an end token. Every
child node is a full node structure itself as defined above.

NOTE: The above definition requires that all property definitions for
a particular node MUST precede any subnode definitions for that node.
Although the structure would not be ambiguous if properties and
subnodes were intermingled, the kernel parser requires that the
properties come first (up until at least 2.6.22).  Any tools
manipulating a flattened tree must take care to preserve this
constraint.

4) Device tree "strings" block

In order to save space, property names, which are generally redundant,
are stored separately in the "strings" block. This block is simply the
whole bunch of zero terminated strings for all property names
concatenated together. The device-tree property definitions in the
structure block will contain offset values from the beginning of the
strings block.


III - libfdt
============

This library should be merged into dtc proper.
This library should likely be worked into U-Boot and the kernel.


IV - Utility Tools
==================

1) convert-dtsv0 -- Conversion to Version 1

convert-dtsv0 is a small utility program which converts (DTS)
Device Tree Source from the obsolete version 0 to version 1.

Version 1 DTS files are marked by line "/dts-v1/;" at the top of the file.

The syntax of the convert-dtsv0 command line is:

    convert-dtsv0 [<input_filename ... >]

Each file passed will be converted to the new /dts-v1/ version by creating
a new file with a "v1" appended the filename.

Comments, empty lines, etc. are preserved.


2) ftdump -- Flat Tree dumping utility

The ftdump program prints a readable version of a flat device tree file.

The syntax of the ftdump command line is:

    ftdump <DTB-file-name>
